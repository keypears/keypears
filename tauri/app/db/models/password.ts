import { db } from "../index";
import { secretUpdates } from "../schema";
import { eq, and, desc, sql } from "drizzle-orm";
import { SecretUpdateSchema } from "@keypears/lib";
import type { SecretUpdate } from "@keypears/lib";

export interface SecretUpdateRow {
  id: string;
  vaultId: string;
  secretId: string;
  name: string;
  type: "password" | "envvar" | "apikey" | "walletkey" | "passkey";
  folders?: string[];
  tags?: string[];
  domain: string | null;
  username: string | null;
  email: string | null;
  encryptedData: string | null;
  encryptedNotes: string | null;
  createdAt: number;
  deleted: boolean;
}

/**
 * Creates a new secret update (for create, edit, or delete operations)
 */
export async function createSecretUpdate(
  update: Omit<SecretUpdate, "id" | "createdAt" | "type"> & {
    vaultId: string;
    type?: SecretUpdate["type"];
    createdAt?: number;
  },
): Promise<SecretUpdateRow> {
  const now = update.createdAt ?? Date.now();

  // Build the complete SecretUpdate object
  const secretUpdate: SecretUpdate = {
    id: "", // Will be generated by ULID in database
    secretId: update.secretId,
    name: update.name,
    type: update.type ?? "password",
    folders: update.folders,
    tags: update.tags,
    domain: update.domain,
    username: update.username,
    email: update.email,
    encryptedData: update.encryptedData,
    encryptedNotes: update.encryptedNotes,
    createdAt: now,
    deleted: update.deleted,
  };

  // Validate with schema (will throw if invalid)
  SecretUpdateSchema.parse(secretUpdate);

  // Serialize to JSON for storage
  const secretUpdateJson = JSON.stringify(secretUpdate);

  // Insert into database - store full JSON + duplicate key fields for indexing
  await db.insert(secretUpdates).values({
    vaultId: update.vaultId,
    secretId: update.secretId,
    name: update.name,
    type: update.type ?? "password",
    createdAt: now,
    deleted: update.deleted ?? false,
    secretUpdateJson,
  });

  // Fetch and return the newly created update
  const result = await db
    .select()
    .from(secretUpdates)
    .where(
      and(
        eq(secretUpdates.vaultId, update.vaultId),
        eq(secretUpdates.secretId, update.secretId),
        eq(secretUpdates.createdAt, now),
      ),
    )
    .limit(1);

  if (!result[0]) {
    throw new Error("Failed to create secret update");
  }

  // Parse the JSON and return as SecretUpdateRow
  const parsed = JSON.parse(result[0].secretUpdateJson) as SecretUpdate;

  return {
    id: result[0].id,
    vaultId: update.vaultId,
    secretId: parsed.secretId,
    name: parsed.name,
    type: (parsed.type ?? "password") as SecretUpdateRow["type"],
    folders: parsed.folders,
    tags: parsed.tags,
    domain: parsed.domain ?? null,
    username: parsed.username ?? null,
    email: parsed.email ?? null,
    encryptedData: parsed.encryptedData ?? null,
    encryptedNotes: parsed.encryptedNotes ?? null,
    createdAt: parsed.createdAt,
    deleted: parsed.deleted ?? false,
  };
}

/**
 * Gets all secret updates for a vault (for history/sync)
 */
export async function getSecretUpdates(
  vaultId: string,
): Promise<SecretUpdateRow[]> {
  const results = await db
    .select()
    .from(secretUpdates)
    .where(eq(secretUpdates.vaultId, vaultId))
    .orderBy(desc(secretUpdates.createdAt));

  return results.map((row) => {
    const parsed = JSON.parse(row.secretUpdateJson) as SecretUpdate;
    return {
      id: row.id,
      vaultId,
      secretId: parsed.secretId,
      name: parsed.name,
      type: (parsed.type ?? "password") as SecretUpdateRow["type"],
      folders: parsed.folders,
      tags: parsed.tags,
      domain: parsed.domain ?? null,
      username: parsed.username ?? null,
      email: parsed.email ?? null,
      encryptedData: parsed.encryptedData ?? null,
      encryptedNotes: parsed.encryptedNotes ?? null,
      createdAt: parsed.createdAt,
      deleted: parsed.deleted ?? false,
    };
  });
}

/**
 * Gets the current (latest non-deleted) secrets for a vault
 * Uses a subquery to find the latest createdAt for each secretId
 */
export async function getCurrentSecrets(
  vaultId: string,
): Promise<SecretUpdateRow[]> {
  // Subquery to get the maximum createdAt for each secretId
  const latestUpdates = db
    .select({
      secretId: secretUpdates.secretId,
      maxCreatedAt: sql<number>`MAX(${secretUpdates.createdAt})`.as(
        "max_created_at",
      ),
    })
    .from(secretUpdates)
    .where(eq(secretUpdates.vaultId, vaultId))
    .groupBy(secretUpdates.secretId)
    .as("latest_updates");

  // Join with the main table to get the full records
  const results = await db
    .select({
      id: secretUpdates.id,
      secretUpdateJson: secretUpdates.secretUpdateJson,
    })
    .from(secretUpdates)
    .innerJoin(
      latestUpdates,
      and(
        eq(secretUpdates.secretId, latestUpdates.secretId),
        eq(secretUpdates.createdAt, latestUpdates.maxCreatedAt),
      ),
    )
    .where(eq(secretUpdates.vaultId, vaultId))
    .orderBy(secretUpdates.name);

  return results.map((row) => {
    const parsed = JSON.parse(row.secretUpdateJson) as SecretUpdate;
    return {
      id: row.id,
      vaultId,
      secretId: parsed.secretId,
      name: parsed.name,
      type: (parsed.type ?? "password") as SecretUpdateRow["type"],
      folders: parsed.folders,
      tags: parsed.tags,
      domain: parsed.domain ?? null,
      username: parsed.username ?? null,
      email: parsed.email ?? null,
      encryptedData: parsed.encryptedData ?? null,
      encryptedNotes: parsed.encryptedNotes ?? null,
      createdAt: parsed.createdAt,
      deleted: parsed.deleted ?? false,
    };
  });
}

/**
 * Gets all updates for a specific secret (history)
 */
export async function getSecretHistory(
  secretId: string,
): Promise<SecretUpdateRow[]> {
  const results = await db
    .select({
      id: secretUpdates.id,
      vaultId: secretUpdates.vaultId,
      secretUpdateJson: secretUpdates.secretUpdateJson,
    })
    .from(secretUpdates)
    .where(eq(secretUpdates.secretId, secretId))
    .orderBy(desc(secretUpdates.createdAt));

  return results.map((row) => {
    const parsed = JSON.parse(row.secretUpdateJson) as SecretUpdate;
    return {
      id: row.id,
      vaultId: row.vaultId,
      secretId: parsed.secretId,
      name: parsed.name,
      type: (parsed.type ?? "password") as SecretUpdateRow["type"],
      folders: parsed.folders,
      tags: parsed.tags,
      domain: parsed.domain ?? null,
      username: parsed.username ?? null,
      email: parsed.email ?? null,
      encryptedData: parsed.encryptedData ?? null,
      encryptedNotes: parsed.encryptedNotes ?? null,
      createdAt: parsed.createdAt,
      deleted: parsed.deleted ?? false,
    };
  });
}
