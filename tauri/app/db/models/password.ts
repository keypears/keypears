import { db } from "../index";
import { passwordUpdates } from "../schema";
import { eq, and, desc, sql } from "drizzle-orm";
import { PasswordUpdateSchema } from "@keypears/lib";
import type { PasswordUpdate } from "@keypears/lib";

export interface PasswordUpdateRow {
  id: string;
  vaultId: string;
  secretId: string;
  name: string;
  domain: string | null;
  username: string | null;
  email: string | null;
  notes: string | null;
  encryptedPassword: string | null;
  createdAt: number;
  deleted: boolean;
}

/**
 * Creates a new password update (for create, edit, or delete operations)
 */
export async function createPasswordUpdate(
  update: Omit<PasswordUpdate, "id" | "createdAt"> & {
    vaultId: string;
    createdAt?: number;
  },
): Promise<PasswordUpdateRow> {
  const now = update.createdAt ?? Date.now();

  // Validate the update using Zod schema (excluding vaultId which is internal)
  const validateData: PasswordUpdate = {
    id: "", // Will be generated by ULID
    secretId: update.secretId,
    name: update.name,
    domain: update.domain,
    username: update.username,
    email: update.email,
    notes: update.notes,
    encryptedPassword: update.encryptedPassword,
    createdAt: now,
    deleted: update.deleted,
  };

  // Validate with schema (will throw if invalid)
  PasswordUpdateSchema.parse(validateData);

  // Insert into database
  await db.insert(passwordUpdates).values({
    vaultId: update.vaultId,
    secretId: update.secretId,
    name: update.name,
    domain: update.domain,
    username: update.username,
    email: update.email,
    notes: update.notes,
    encryptedPassword: update.encryptedPassword,
    createdAt: now,
    deleted: update.deleted ?? false,
  });

  // Fetch and return the newly created update
  const result = await db
    .select()
    .from(passwordUpdates)
    .where(
      and(
        eq(passwordUpdates.vaultId, update.vaultId),
        eq(passwordUpdates.secretId, update.secretId),
        eq(passwordUpdates.createdAt, now),
      ),
    )
    .limit(1);

  if (!result[0]) {
    throw new Error("Failed to create password update");
  }

  return result[0];
}

/**
 * Gets all password updates for a vault (for history/sync)
 */
export async function getPasswordUpdates(
  vaultId: string,
): Promise<PasswordUpdateRow[]> {
  return await db
    .select()
    .from(passwordUpdates)
    .where(eq(passwordUpdates.vaultId, vaultId))
    .orderBy(desc(passwordUpdates.createdAt));
}

/**
 * Gets the current (latest non-deleted) passwords for a vault
 * Uses a subquery to find the latest createdAt for each secretId
 */
export async function getCurrentPasswords(
  vaultId: string,
): Promise<PasswordUpdateRow[]> {
  // Subquery to get the maximum createdAt for each secretId
  const latestUpdates = db
    .select({
      secretId: passwordUpdates.secretId,
      maxCreatedAt: sql<number>`MAX(${passwordUpdates.createdAt})`.as(
        "max_created_at",
      ),
    })
    .from(passwordUpdates)
    .where(eq(passwordUpdates.vaultId, vaultId))
    .groupBy(passwordUpdates.secretId)
    .as("latest_updates");

  // Join with the main table to get the full records
  const results = await db
    .select({
      id: passwordUpdates.id,
      vaultId: passwordUpdates.vaultId,
      secretId: passwordUpdates.secretId,
      name: passwordUpdates.name,
      domain: passwordUpdates.domain,
      username: passwordUpdates.username,
      email: passwordUpdates.email,
      notes: passwordUpdates.notes,
      encryptedPassword: passwordUpdates.encryptedPassword,
      createdAt: passwordUpdates.createdAt,
      deleted: passwordUpdates.deleted,
    })
    .from(passwordUpdates)
    .innerJoin(
      latestUpdates,
      and(
        eq(passwordUpdates.secretId, latestUpdates.secretId),
        eq(passwordUpdates.createdAt, latestUpdates.maxCreatedAt),
      ),
    )
    .where(eq(passwordUpdates.vaultId, vaultId))
    .orderBy(passwordUpdates.name);

  return results;
}

/**
 * Gets all updates for a specific password (history)
 */
export async function getPasswordHistory(
  secretId: string,
): Promise<PasswordUpdateRow[]> {
  return await db
    .select()
    .from(passwordUpdates)
    .where(eq(passwordUpdates.secretId, secretId))
    .orderBy(desc(passwordUpdates.createdAt));
}
