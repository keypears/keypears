{
    "version": "https://jsonfeed.org/version/1",
    "title": "KeyPears Blog",
    "home_page_url": "https://keypears.com",
    "feed_url": "https://keypears.com/blog/feed.json",
    "description": "Updates and insights from the KeyPears team",
    "items": [
        {
            "id": "https://keypears.com/blog/2025-10-04-drizzle-sqlite-tauri",
            "content_html": "<p><em>Published: October 4, 2025</em></p>\n<p><strong>Note:</strong> KeyPears is a work-in-progress open-source password manager. The\nsolutions described here are part of our development process and may evolve\nbefore our official release.</p>\n<h2>The Problem</h2>\n<p>Building a local-first application with Tauri 2.0, we needed a robust database\nsolution for storing encrypted vault data on users' devices. We wanted:</p>\n<ul>\n<li>Type-safe database queries</li>\n<li>Proper schema migrations that work in production</li>\n<li>Pure TypeScript implementation (no Rust for basic DB operations)</li>\n<li>A solution that works across desktop and mobile platforms</li>\n</ul>\n<p>After evaluating options, we chose <strong>Drizzle ORM</strong> with <strong>SQLite</strong> via the\nofficial <strong>tauri-plugin-sql</strong>. This combination gives us TypeScript-first\ndevelopment with the reliability of SQLite.</p>\n<h2>The Challenge</h2>\n<p>Unlike traditional Node.js environments where you have direct filesystem access\nand can use drivers like <code>better-sqlite3</code>, Tauri's sandboxed environment\nrequires a different approach. Drizzle's standard migration tools assume direct\ndatabase access, but with Tauri, we need to go through the plugin system.</p>\n<p>Here's how we solved it.</p>\n<h2>Tech Stack</h2>\n<ul>\n<li><strong>Tauri 2.0</strong> - Cross-platform app framework</li>\n<li><strong>Drizzle ORM</strong> - TypeScript ORM</li>\n<li><strong>drizzle-kit</strong> - Schema migration generator</li>\n<li><strong>@tauri-apps/plugin-sql</strong> - Official Tauri SQLite plugin</li>\n<li><strong>React Router</strong> - For app routing and loaders</li>\n</ul>\n<h2>Step 1: Install Dependencies</h2>\n<p>First, add the necessary packages:</p>\n<pre><code class=\"language-bash\"># Production dependencies\npnpm add drizzle-orm @tauri-apps/plugin-sql\n\n# Development dependencies\npnpm add -D drizzle-kit\n</code></pre>\n<p>Then add the Tauri plugin to your Rust dependencies in <code>src-tauri/Cargo.toml</code>:</p>\n<pre><code class=\"language-toml\">[dependencies]\ntauri-plugin-sql = { version = \"2\", features = [\"sqlite\"] }\n</code></pre>\n<h2>Step 2: Configure Tauri Permissions</h2>\n<p>Tauri 2.0 requires explicit permission grants. Add SQL permissions to\n<code>src-tauri/capabilities/default.json</code>:</p>\n<pre><code class=\"language-json\">{\n  \"$schema\": \"../gen/schemas/desktop-schema.json\",\n  \"identifier\": \"default\",\n  \"description\": \"Capability for the main window\",\n  \"windows\": [\"main\"],\n  \"permissions\": [\n    \"core:default\",\n    \"sql:default\",\n    \"sql:allow-load\",\n    \"sql:allow-execute\",\n    \"sql:allow-select\",\n    \"sql:allow-close\"\n  ]\n}\n</code></pre>\n<p>Without these permissions, you'll get \"not allowed\" errors when trying to access\nthe database.</p>\n<h2>Step 3: Define Your Schema</h2>\n<p>Create your Drizzle schema at <code>app/db/schema.ts</code>:</p>\n<pre><code class=\"language-typescript\">import { sqliteTable, text, integer } from \"drizzle-orm/sqlite-core\";\n\nexport const vaults = sqliteTable(\"vaults\", {\n  id: integer(\"id\").primaryKey({ autoIncrement: true }),\n  name: text(\"name\").notNull().unique(),\n});\n</code></pre>\n<h2>Step 4: Set Up the SQLite Proxy</h2>\n<p>Since we can't use standard SQLite drivers in Tauri, we use Drizzle's\n<code>sqlite-proxy</code> adapter. Create <code>app/db/index.ts</code>:</p>\n<pre><code class=\"language-typescript\">import { drizzle } from \"drizzle-orm/sqlite-proxy\";\nimport Database from \"@tauri-apps/plugin-sql\";\nimport * as schema from \"./schema\";\n\nexport async function getDb() {\n  return await Database.load(\"sqlite:keypears.db\");\n}\n\nfunction isSelectQuery(sql: string): boolean {\n  return sql.trim().toLowerCase().startsWith(\"select\");\n}\n\nexport const db = drizzle&#x3C;typeof schema>(\n  async (sql, params, method) => {\n    const sqlite = await getDb();\n    let rows: any = [];\n\n    if (isSelectQuery(sql)) {\n      rows = await sqlite.select(sql, params).catch((e) => {\n        console.error(\"SQL Error:\", e);\n        return [];\n      });\n    } else {\n      rows = await sqlite.execute(sql, params).catch((e) => {\n        console.error(\"SQL Error:\", e);\n        return [];\n      });\n      return { rows: [] };\n    }\n\n    rows = rows.map((row: any) => Object.values(row));\n    const results = method === \"all\" ? rows : rows[0];\n    await sqlite.close();\n    return { rows: results };\n  },\n  { schema: schema, logger: true }\n);\n</code></pre>\n<p>The proxy adapter translates Drizzle queries into calls to the Tauri SQL plugin.</p>\n<h2>Step 5: Configure Migration Generation</h2>\n<p>Create <code>drizzle.config.ts</code>:</p>\n<pre><code class=\"language-typescript\">import type { Config } from \"drizzle-kit\";\n\nexport default {\n  schema: \"./app/db/schema.ts\",\n  out: \"./app/db/migrations\",\n  dialect: \"sqlite\",\n} satisfies Config;\n</code></pre>\n<p>Add a script to <code>package.json</code>:</p>\n<pre><code class=\"language-json\">{\n  \"scripts\": {\n    \"db:migrate\": \"drizzle-kit generate\"\n  }\n}\n</code></pre>\n<h2>Step 6: Implement Migration Runner</h2>\n<p>Here's the key part - implementing our own migration system. Create\n<code>app/db/migrate.ts</code>:</p>\n<pre><code class=\"language-typescript\">import { getDb } from \"./index\";\n\n// Dynamically import all SQL migration files\nconst migrationFiles = import.meta.glob&#x3C;string>(\"./migrations/*.sql\", {\n  query: \"?raw\",\n  import: \"default\",\n  eager: true,\n});\n\n// Create migrations tracking table\nasync function ensureMigrationsTable() {\n  const sqlite = await getDb();\n  await sqlite.execute(`\n    CREATE TABLE IF NOT EXISTS __drizzle_migrations (\n      id INTEGER PRIMARY KEY AUTOINCREMENT,\n      hash TEXT NOT NULL UNIQUE,\n      created_at INTEGER NOT NULL\n    )\n  `);\n  await sqlite.close();\n}\n\n// Get list of applied migrations\nasync function getAppliedMigrations(): Promise&#x3C;string[]> {\n  const sqlite = await getDb();\n  const rows = await sqlite\n    .select&#x3C;Array&#x3C;{ hash: string }>>(\n      \"SELECT hash FROM __drizzle_migrations ORDER BY id\"\n    )\n    .catch(() => []);\n  await sqlite.close();\n  return rows.map((row) => row.hash);\n}\n\n// Record migration as applied\nasync function recordMigration(hash: string) {\n  const sqlite = await getDb();\n  const timestamp = Date.now();\n  await sqlite.execute(\n    \"INSERT INTO __drizzle_migrations (hash, created_at) VALUES (?, ?)\",\n    [hash, timestamp]\n  );\n  await sqlite.close();\n}\n\n// Execute SQL file\nasync function executeSqlFile(sqlContent: string) {\n  const sqlite = await getDb();\n  const statements = sqlContent\n    .split(\"--> statement-breakpoint\")\n    .map((s) => s.trim())\n    .filter((s) => s.length > 0);\n\n  for (const statement of statements) {\n    await sqlite.execute(statement).catch((e) => {\n      console.error(\"Migration error:\", e);\n      throw e;\n    });\n  }\n\n  await sqlite.close();\n}\n\nexport async function runMigrations() {\n  console.log(\"Running database migrations...\");\n\n  try {\n    await ensureMigrationsTable();\n    const appliedMigrations = await getAppliedMigrations();\n\n    const migrationPaths = Object.keys(migrationFiles).sort();\n\n    const pendingMigrations = migrationPaths.filter((path) => {\n      const filename = path.split(\"/\").pop() || path;\n      return !appliedMigrations.includes(filename);\n    });\n\n    if (pendingMigrations.length === 0) {\n      console.log(\"All migrations already applied\");\n      return;\n    }\n\n    for (const path of pendingMigrations) {\n      const filename = path.split(\"/\").pop() || path;\n      const migrationContent = migrationFiles[path];\n\n      console.log(`Executing migration: ${filename}`);\n      await executeSqlFile(migrationContent);\n      await recordMigration(filename);\n      console.log(`✓ Applied: ${filename}`);\n    }\n\n    console.log(`Successfully completed ${pendingMigrations.length} migration(s)`);\n  } catch (error) {\n    console.error(\"Migration failed:\", error);\n    throw error;\n  }\n}\n</code></pre>\n<p>This implements Drizzle's migration tracking pattern:</p>\n<ul>\n<li>Uses <code>__drizzle_migrations</code> table to track applied migrations</li>\n<li>Only runs new migrations on subsequent app launches</li>\n<li>Supports incremental migrations as your schema evolves</li>\n</ul>\n<h2>Step 7: Run Migrations on App Startup</h2>\n<p>In your root component (<code>app/root.tsx</code>), use a clientLoader to run migrations\nbefore rendering:</p>\n<pre><code class=\"language-typescript\">import { runMigrations } from \"./db/migrate\";\n\nexport async function clientLoader() {\n  await runMigrations();\n  return null;\n}\n\nexport function HydrateFallback() {\n  return (\n    &#x3C;div className=\"flex min-h-screen items-center justify-center\">\n      &#x3C;h1>Migrating the database...&#x3C;/h1>\n    &#x3C;/div>\n  );\n}\n</code></pre>\n<p>React Router will show the fallback while migrations run, ensuring the database\nis ready before any component renders.</p>\n<h2>Step 8: Create Model Functions</h2>\n<p>With everything set up, create type-safe model functions at\n<code>app/db/models/vault.ts</code>:</p>\n<pre><code class=\"language-typescript\">import { db } from \"../index\";\nimport { vaults } from \"../schema\";\nimport { eq, count } from \"drizzle-orm\";\n\nexport interface Vault {\n  id: number;\n  name: string;\n}\n\nexport async function createVault(name: string): Promise&#x3C;Vault> {\n  const result = await db.insert(vaults).values({ name }).returning();\n  return result[0];\n}\n\nexport async function getVault(id: number): Promise&#x3C;Vault | undefined> {\n  const result = await db.select().from(vaults).where(eq(vaults.id, id));\n  return result[0];\n}\n\nexport async function getVaults(): Promise&#x3C;Vault[]> {\n  return await db.select().from(vaults);\n}\n\nexport async function countVaults(): Promise&#x3C;number> {\n  const result = await db.select({ count: count() }).from(vaults);\n  return result[0]?.count ?? 0;\n}\n</code></pre>\n<h2>Usage Workflow</h2>\n<h3>Development</h3>\n<p>When you modify your schema:</p>\n<pre><code class=\"language-bash\"># 1. Update app/db/schema.ts\n# 2. Generate new migration\npnpm run db:migrate\n\n# 3. Restart app - migration runs automatically\n</code></pre>\n<p>During development, you can safely delete all migrations and regenerate them\nfrom scratch. Just delete the database file and migration files, then\nregenerate.</p>\n<h3>Production</h3>\n<p>Before releasing v1.0:</p>\n<ol>\n<li>Delete all development migrations</li>\n<li>Generate one clean migration from your final schema</li>\n<li>Commit this as your baseline</li>\n</ol>\n<p>After release, <strong>never delete migrations</strong> - only add new ones. Users will have\nthe old migrations applied, and new migrations build incrementally.</p>\n<h2>Database File Location</h2>\n<p>The Tauri SQL plugin creates the database in the app's data directory:</p>\n<ul>\n<li><strong>macOS</strong>: <code>~/Library/Application Support/{app-identifier}/keypears.db</code></li>\n<li><strong>Linux</strong>: <code>~/.local/share/{app-identifier}/keypears.db</code></li>\n<li><strong>Windows</strong>: <code>%APPDATA%\\{app-identifier}\\keypears.db</code></li>\n</ul>\n<h2>Troubleshooting</h2>\n<p><strong>Permission errors</strong>: Make sure you've added all SQL permissions to\n<code>capabilities/default.json</code></p>\n<p><strong>Migration fails</strong>: Check browser console in the Tauri webview for detailed\nerror messages</p>\n<p><strong>Type errors</strong>: Run <code>pnpm run typecheck</code> to catch issues before runtime</p>\n<h2>Conclusion</h2>\n<p>This setup gives us:</p>\n<ul>\n<li>✅ Type-safe database queries with Drizzle</li>\n<li>✅ Proper migration tracking that works in production</li>\n<li>✅ Pure TypeScript - no Rust code needed for basic operations</li>\n<li>✅ Cross-platform compatibility (desktop &#x26; mobile)</li>\n<li>✅ Incremental migrations as the schema evolves</li>\n</ul>\n<p>The combination of Drizzle's <code>sqlite-proxy</code> adapter with Tauri's SQL plugin\nprovides a robust foundation for local-first data storage. While we had to\nimplement our own migration runner, we followed Drizzle's patterns to ensure\ncompatibility and maintainability.</p>\n<h2>Resources</h2>\n<ul>\n<li><a href=\"https://orm.drizzle.team/\">Drizzle ORM</a></li>\n<li><a href=\"https://v2.tauri.app/plugin/sql/\">Tauri SQL Plugin</a></li>\n<li><a href=\"https://v2.tauri.app/security/capabilities/\">Tauri Capabilities</a></li>\n</ul>\n<hr>\n<p><em>Have questions or suggestions? We'd love to hear your feedback!</em></p>",
            "url": "https://keypears.com/blog/2025-10-04-drizzle-sqlite-tauri",
            "title": "Drizzle SQLite Database Migrations in Tauri 2.0",
            "summary": "<p><em>Published: October 4, 2025</em></p>\n<p><strong>Note:</strong> KeyPears is a work-in-progress open-source password manager. The\nsolutions described here are part of our development process and m...",
            "date_modified": "2025-10-04T00:00:00.000Z",
            "author": {
                "name": "KeyPears Team"
            }
        },
        {
            "id": "https://keypears.com/blog/2025-10-03-introducing-keypears",
            "content_html": "<p>We're excited to announce KeyPears, a new password manager designed for the\nmodern era of digital security and self-custody.</p>\n<h2>Why KeyPears?</h2>\n<p>Traditional password managers have served us well, but they come with\nlimitations. Most rely on centralized services, creating single points of\nfailure and raising questions about who truly controls your most sensitive data.\nKeyPears takes a different approach.</p>\n<h2>Local-First, Sync-Enabled</h2>\n<p>KeyPears is built on a local-first architecture. Your secrets live on your\ndevices, encrypted with keys only you control. But unlike purely local\nsolutions, KeyPears solves the synchronization problem through a permissionless\nmarketplace of third-party service providers using an open protocol—similar to\nhow email works.</p>\n<p>Anyone can run a KeyPears node. The protocol is open source. You maintain full\nself-custody while enjoying seamless synchronization across all your devices.</p>\n<h2>Built for Sharing</h2>\n<p>Modern work requires secure secret sharing. KeyPears uses end-to-end encryption\nwith public/private key pairs for each user. When alice@example.com needs to\nshare a secret with bob@example2.com, they use Diffie-Hellman key exchange to\nderive a shared secret that only they know. The architecture mirrors email, but\nwith cryptography-first design.</p>\n<h2>More Than Passwords</h2>\n<p>While we call it a password manager, KeyPears is designed to handle:</p>\n<ul>\n<li>Passwords</li>\n<li>Cryptocurrency wallet keys</li>\n<li>API keys</li>\n<li>Environment variables</li>\n<li>SSH keys</li>\n<li>PGP keys</li>\n</ul>\n<p>For cryptocurrency users seeking self-custody and businesses that need secure\nsecret sharing without expensive enterprise subscriptions, KeyPears offers a\ncompelling alternative.</p>\n<h2>What's Next</h2>\n<p>KeyPears is in active development. We're building native applications for\nWindows, macOS, Linux, Android, and iOS using Tauri. The project is Apache 2.0\nlicensed and open source.</p>\n<p>This is just the beginning. We're excited to build KeyPears with the community\nand create a new standard for secure, self-custodied secret management.</p>\n<p>Stay tuned for more updates as we continue development.</p>",
            "url": "https://keypears.com/blog/2025-10-03-introducing-keypears",
            "title": "Introducing KeyPears: A New Approach to Password Management",
            "summary": "<p>We're excited to announce KeyPears, a new password manager designed for the\nmodern era of digital security and self-custody.</p>\n<h2>Why KeyPears?</h2>\n<p>Traditional password managers have served ...",
            "date_modified": "2025-10-03T00:00:00.000Z",
            "author": {
                "name": "KeyPears Team"
            }
        }
    ]
}